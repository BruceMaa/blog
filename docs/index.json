[{"categories":["Java"],"content":"文章描述","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-01/","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-01","uri":"/2016/11/java-middleware-note-01/"},{"categories":["Java"],"content":"第1章 分布式系统介绍 ","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-01/:1:0","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-01","uri":"/2016/11/java-middleware-note-01/"},{"categories":["Java"],"content":"1.1 初识分布式系统 1.1.1 分布式系统的定义 首先分布式系统一定是由多个节点组成的系统，一般来说一个节点就是我们的一台计算机；然后这些节点不是孤立的，而是互相连通的；最后，这些连通的节点上部署了我们的组建，并且相互之间的操作会有协同。 1.1.2 分布式系统的意义 下面三个方面 * 升级单机处理能力的性价比越来越低。 * 单机处理能力存在瓶颈。 * 出于稳定性和可用性的考虑。 ","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-01/:1:1","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-01","uri":"/2016/11/java-middleware-note-01/"},{"categories":["Java"],"content":"1.2 分布式系统的基础知识 1.2.1 组成计算机的5要素 冯 ∘ 诺依曼型计算机的5个组成部分： * 输入设备 * 输出设备 * 运算器 * 控制器 * 存储器——内存和外存 1.2.2 线程与进程的执行模式 一个进程可以有多个线程，一个线程只属于一个进程。 1.2.2.1 阿姆达尔定律 Amdahl’s law: S(N) = 1 / ((1 - P) + P / N) 其中，P指的是程序中可并行部分的程序在单核上执行时间的占比，N表示处理器的个数（总核心数）。S(N)是指程序在N个处理器（总核心数）相对在单个处理器（单核）中的速度提升比。 这个公式告诉我们，程序中可并行代码的比例决定你增加处理器（总核心数）所能带来的速度提升的上限，是否能达到这个上限，还取决于很多其它的因素。 1.2.2.2 互不通信的多线程模式 两个线程，没有交集，各自执行各自的任务和逻辑。 1.2.2.3 基于共享容器协同的多线程模式 有一个队列用于生产和消费，那么，这个队列就是多个线程会共享的一个容器或者是数据对象，多个线程会并发访问这个队列。 需要加锁控制并发。 1.2.2.4 通过事件协同的多线程模式 一个线程需要另一个线程的触发才能执行。 防止死锁。 1.2.2.5 多进程模式 多进程和多线程有比较多的相似之处，也有不同。不同的最大原因是，线程是属于进程的，一个进程内的多个线程共享了进程的内存空间；而多个进程之间的内存空间是独立的，因此多个进程间通过内存共享、交换数据的方式与多个线程间的方式就有所不同。此外，进程间的通信、协调，以及通过一些事件通知活着等待一些互斥锁的释放方面，也会与多线程不一样。 1.2.3 网络通信基础知识 在分布式系统中，组件分布在网络上的多个节点中，通过消息的传递来通信并且进行动作的协调。因此网络通信在分布式系统中非常重要。 1.2.3.1 OSI与TCP/IP网络模型 ISO的OSI网络模型 * Application Layer * Presentation Layer * Session Layer * Transport Layer * Network Layer * Data Link Layer * Physical Layer TCP/IP网络模型 * Application * Transport * Internetwork * Network Interface 1.2.3.2 网络IO实现方式 1.2.3.2.1 BIO方式 BIO即Blocking IO，采用阻塞的方式实现。也就是一个Socket套接字需要使用一个线程来进行处理。发生建立连接、读数据、写数据的操作时，都可能会阻塞。 1.2.3.2.2 NIO方式 NIO即Nonblocking IO，基于事件驱动思想，采用的是Reactor模式。 在NIO的方式下不是用单个线程去应对单个Socket套接字，而是统一通过Reactor对所有客户端的Socket套接字的事件做处理，然后派发到不同的线程中。 1.2.3.2.3 AIO方式 AIO即AsynchronousIO，就是异步IO。AIO采用Proactor模式。AIO与NIO的差别是，AIO在进行读写操作时，只需要调用相对应的read/write方法，并且需要传入CompletionHandler；在动作完成后，会调用CompletionHandler。 1.2.4 如何把应用从单机扩展到分布式 1.2.4.1 输入设备的变化 将分布式中的某个节点作为输入设备。 1.2.4.2 输出设备的变化 将分布式中的某个节点作为输出设备。 1.2.4.3 控制器的变化 单机系统中，控制器就是CPU中的控制器。在分布式系统中，负载均衡系统就算是一种控制器。 使用硬件负载均衡的请求调用 在集群中，这种方式对于发起请求的一方和处理请求的一方来说，都是透明的，可以称为透明代理。 使用LVS的请求调用 这种方式存在两个不足： * 会增加网络的开销，这个开销一方面指的是流量，另外一方面指的是延迟。 * 这个透明代理处于请求的必经路径上，如果代理出现问题，那么所有的请求都会受到影响。 采用名称服务的直连方式的请求调用 在请求发起方和请求处理方的直接连接外部，有一个“名称服务”的角色，它的作用主要有两个，一个是收集提供请求处理的服务器的地址信息；另外一个是提供这些地址信息给请求发起方。 采用规则服务器控制路由的请求直接调用 在请求发起的机器上，会有对规则进行处理从而进行请求处理服务机器选择的代码逻辑。这个方式与名称服务方式的不同在于，名称服务是通过跟请求处理的机器交互来获得这些机器的地址的，而规则服务器的方式中，规则服务器本身并不和请求处理的机器进行交互，只负责把规则提供给请求发起的机器。 Master + Worder的方式 存在一个Master节点来管理任务，由Master把任务分配给不同的Worker去进行处理。 1.2.4.4 运算器的变化 在单机系统中，运算器是具体的电子元件，而在分布式系统中，运算器是由多个节点来组成的。 总结起来，构成运算器的多个节点在控制器的配合下对外提供服务，构成了分布式系统中的运算器。 1.2.4.5 存储器的变化 方案与前面相同，依次是代理、名称服务、规则服务、Master-Worker服务。 1.2.5 分布式系统的难点 1.2.5.1 缺乏全局时钟 很多时候我们使用时钟，它可以区分两个动作的顺序，而不一定要知道准确的时间。这种情况需要交给一个单独的集群来处理。 1.2.5.2 面对故障独立性 在分布式系统中，整个系统的一部分有问题而其它部分正常是经常出现的情况，我们称之为故障独立性。 1.2.5.3 处理单点故障 在整个分布式系统中，如果某个角色或者功能只有某台单机在支撑，那么这个节点称为单点，其发生的故障称为单点故障，也是常说的SPoF(Single Point of Failure)。 一台数据库拆分到多台数据库后，出现故障的次数和总时间会比单台数据库的时候要多。也就是说，我们增加了故障出现的次数和时间，降低了故障的影响面。 1.2.5.4 事物的挑战 ","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-01/:1:2","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-01","uri":"/2016/11/java-middleware-note-01/"},{"categories":["DevTools"],"content":"文章描述","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"介绍 ownCloud是一种私人文件系统，在公司内部搭建方便上传、下载以及分享文件。 产品可以上传需求文件，测试可以上传测试用例。 参考地址：http://tecadmin.net/install-owncloud-on-centos/ ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:1:0","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"安装 ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:0","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"第一步 添加仓库的yum源 rpm -Uvh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:1","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"第二步 安装LAMP环境 安装Apache，有的是系统默认安装 yum —enablerepo=remi,epel install httpd 安装MySQL yum —enablerepo=remi,epel install mysql-server service mysqld start mysql_secure_installation 安装PHP环境 yum --enablerepo=remi,epel install php php-mysql php-mcrypt php-curl php-gd php-xml php-mbstring ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:2","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"第三步 下载owncloud源码 wget https://download.owncloud.org/community/owncloud-9.1.1.tar.bz2 tar -xjf owncloud-9.1.1.tar.bz2 -C /var/www/html/ chown -R apache.apache /var/www/html/owncloud chmod -R 755 owncloud 添加链接 我在按照原文安装后，浏览器访问404，查看httpd的错误日志才发现，提示/var/wwwnone/html/owncloud不存在，所以需要在这个位置添加一个链接。 ln -s /var/www/html/owncloud/ /var/wwwnone/html/owncloud 重启httpd服务 service httpd restart ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:3","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"第四步 创建数据库和用户 mysql -uroot -p mysql\u003e CREATE DATABASE owncloud; mysql\u003e GRANT ALL ON owncloud.* TO 'owncloud'@'localhost' IDENTIFIED BY '_password_'; mysql\u003e FLUSH PRIVILEGES; mysql\u003e quit ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:4","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"第五步 开启浏览器访问安装 在浏览器中输入http://ip/owncloud，创建admin用户，填写数据库连接地址，点击完成安装即可。 ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:5","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"文章描述","date":"2016-10-28","objectID":"/2016/10/vim-records/","tags":["VIM"],"title":"VIM操作记录","uri":"/2016/10/vim-records/"},{"categories":["DevTools"],"content":"VIM 的操作记录 ","date":"2016-10-28","objectID":"/2016/10/vim-records/:1:0","tags":["VIM"],"title":"VIM操作记录","uri":"/2016/10/vim-records/"},{"categories":["DevTools"],"content":"初始化过程 配置文件载入过程： /etc/vimrc $HOME/.vim/,$HOME/.vimrc $VIMRUNTIME/.vim/,$VIMRUNTIME/.vimrc $HOME/.vim/after/ 通过运行vim -V可查看整个初始化过程。 ","date":"2016-10-28","objectID":"/2016/10/vim-records/:1:1","tags":["VIM"],"title":"VIM操作记录","uri":"/2016/10/vim-records/"},{"categories":["DevTools"],"content":"操作快捷键 普通模式 h 光标左移一位 l 光标右移一位 j 光标下移一位 k 光标上移一位 H 光标移动到当前屏幕的第一行 M 光标移动到当前屏幕的中间 L 光标移动到当前屏幕的最后一行 zt 光标所在的行移动到屏幕的最上方 zz 光标所在的行移动到屏幕的中间 zb 光标所在的行移动到屏幕的最下方 插入模式 可视模式 替换模式 命令行模式 ","date":"2016-10-28","objectID":"/2016/10/vim-records/:1:2","tags":["VIM"],"title":"VIM操作记录","uri":"/2016/10/vim-records/"},{"categories":["Python"],"content":"文章描述","date":"2016-09-28","objectID":"/2016/09/python-library-collection/","tags":["Python"],"title":"Python第三方库收集","uri":"/2016/09/python-library-collection/"},{"categories":["Python"],"content":"Python 科学计算第三方库 ","date":"2016-09-28","objectID":"/2016/09/python-library-collection/:1:0","tags":["Python"],"title":"Python第三方库收集","uri":"/2016/09/python-library-collection/"},{"categories":["Python"],"content":"matplotlib 绘制一些高质量的的数学二维图形。 pip install --user matplotlib 依赖安装的其它库 pyparsing python-dateutil cycler numpy pytz six ","date":"2016-09-28","objectID":"/2016/09/python-library-collection/:1:1","tags":["Python"],"title":"Python第三方库收集","uri":"/2016/09/python-library-collection/"},{"categories":["Python"],"content":"scipy 基于Python的matlab实现，旨在实现matlab的所有功能。 pip install --user scipy ","date":"2016-09-28","objectID":"/2016/09/python-library-collection/:1:2","tags":["Python"],"title":"Python第三方库收集","uri":"/2016/09/python-library-collection/"},{"categories":["Python"],"content":"numpy 基于Python的科学计算第三方库，提供了矩阵，线性代数，傅立叶变换等等的解决方案。 pip install --user numpy ","date":"2016-09-28","objectID":"/2016/09/python-library-collection/:1:3","tags":["Python"],"title":"Python第三方库收集","uri":"/2016/09/python-library-collection/"},{"categories":["Java"],"content":"Gradle使用记录－－来自官网 ","date":"2016-09-21","objectID":"/2016/09/java-gradle-records/:1:0","tags":["Gradle"],"title":"Gradle使用记录","uri":"/2016/09/java-gradle-records/"},{"categories":["Java"],"content":"安装 1. 先决条件 Gradle需要安装JDK或者JRE，版本为7及以上(可以通过java -version检查)。 配置JAVA_HOME环境变量。 2. 下载 http://www.gradle.org/downloads 3. 解压 4. 配置环境变量 配置GRADLE_HOME，并且将GRADLE_HOME/bin加入到PATH中。 5. 运行并测试安装是否成功 gradle -v 6. 配置JVM参数 可以配置GRADLE_OPTS或者JAVA_OPTS，或者两个都可以。 这些可以配置到环境变量中，也可以配置到gradle或者gradlew之前。 ","date":"2016-09-21","objectID":"/2016/09/java-gradle-records/:1:1","tags":["Gradle"],"title":"Gradle使用记录","uri":"/2016/09/java-gradle-records/"},{"categories":["Java"],"content":"使用Gradle命令行 1. 执行多个任务 创建文件build.gradle task compile \u003c\u003c { println 'compiling source' } task compileTest(dependsOn: compile) \u003c\u003c { println 'compiling unit tests' } task test(dependsOn: [compile, compileTest]) \u003c\u003c { println 'running unit tests' } task dist(dependsOn: [compile, test]) \u003c\u003c { println 'building the distribution' } 保存退出后，执行命令 gradle dist test 2. 拒绝执行任务 使用-x参数拒绝某个任务执行。 gradle dist -x test 你会看到不止test没有执行，test依赖的compileTest也没有执行。 3. 某个任务失败也继续执行 如果使用了--continue参数，无论哪个任务失败，其余的任务都会执行。 4. 任务缩略名 如果你不知道某个任务的全称，只知道简称也可以，不过简称必须是唯一的。 gradle di gradle dist 上面两条命令会输出相同结果。 如果要执行compileTest这个任务，下面的命令都可以 gradle compileTest gradle compTest gradle cT 5. 指定执行的构建文件 当执行gradle命令时，看起来都是在当前路径构建。你可以使用-b参数执行构建文件。如果使用-b参数，则settings.gradle无效。 当多个项目构建时，你可以使用-p参数代替-b参数。 gradle -q -p subdir hello ⚠️目前此命令我没有执行成功，还没有查明原因！！！ 6. 专注任务执行 没看懂 7. 获得构建信息 7.1 列出所选子项目的名单 gradle -q projects 7.2 列出所选主任务的名单 gradle -q tasks 可以加上--all参数获得列出的任务里的更多信息。 7.3 显示任务使用详细信息 gradle help --task someTask 7.4 列出项目的依赖信息 gradle -q dependencies [subpro:dependencies] 由于依赖报告太多，可以使用--configuration参数来限制报告。 gradle -q api:dependencies --configuration testCompile 7.5 列出项目构建脚本的依赖 gradle buildEnvironment ","date":"2016-09-21","objectID":"/2016/09/java-gradle-records/:1:2","tags":["Gradle"],"title":"Gradle使用记录","uri":"/2016/09/java-gradle-records/"},{"categories":["Java"],"content":"文章描述","date":"2016-09-19","objectID":"/2016/09/spring-source-study-1/","tags":["Spring"],"title":"Spring源码深度解析－－学习笔记1","uri":"/2016/09/spring-source-study-1/"},{"categories":["Java"],"content":"Spring源码深度解析－－构建环境 本文是根据《Spring源码深度解析》（编著：郝佳）这本书记录的学习笔记。 ","date":"2016-09-19","objectID":"/2016/09/spring-source-study-1/:1:0","tags":["Spring"],"title":"Spring源码深度解析－－学习笔记1","uri":"/2016/09/spring-source-study-1/"},{"categories":["Java"],"content":"必备环境变量 Git Java 必须是JDK8update20及更新 必须配置JAVA_HOME到jdk1.8.0 ","date":"2016-09-19","objectID":"/2016/09/spring-source-study-1/:1:1","tags":["Spring"],"title":"Spring源码深度解析－－学习笔记1","uri":"/2016/09/spring-source-study-1/"},{"categories":["Java"],"content":"下载源码 git clone https://github.com/spring-projects/spring-framework.git ","date":"2016-09-19","objectID":"/2016/09/spring-source-study-1/:1:2","tags":["Spring"],"title":"Spring源码深度解析－－学习笔记1","uri":"/2016/09/spring-source-study-1/"},{"categories":["Java"],"content":"导入到IDEA 需要先执行一条命令 ./gradlew cleanIdea :spring-oxm:compileTestJava 接下来就是漫长的等待。 根据打印的日志，以及读取gradlew命令文件可知，这是先去下载最新的gradle压缩包了，虽然我已经提前下载并且配置好了。 下载完压缩包，然后是下载需要的jar包，再次漫长的等待后会看到SUCCESS。 接下来执行命令 ./gradlew install 再次漫长等待。。。 成功后再次输入命令 ./gradlew build 我的心，在等待，永远在等待。。。 终于结束了。 使用IDEA的Import Project导入项目，会提示gradle build，没关系，这次会快很多，因为先前已经把该下载的jar包都下载了。 搞定。 ","date":"2016-09-19","objectID":"/2016/09/spring-source-study-1/:1:3","tags":["Spring"],"title":"Spring源码深度解析－－学习笔记1","uri":"/2016/09/spring-source-study-1/"},{"categories":["Database"],"content":"先当草稿记着，之后要分开记录","date":"2016-09-19","objectID":"/2016/09/sql-categories/","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Database"],"content":"SQL分类－－记录来自维基百科 结构化查询语言(英语：Structural Query Language，缩写：SQL) ","date":"2016-09-19","objectID":"/2016/09/sql-categories/:1:0","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Database"],"content":"数据查询语言 英语：Data Query Language，缩写：DQL 负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。 语法结构 SELECT ","date":"2016-09-19","objectID":"/2016/09/sql-categories/:1:1","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Database"],"content":"数据定义语言 英语：Data Definition Language，缩写：DDL 负责数据结构定义与数据库对象定义的语言。 语法结构 CREATE ALTER DROP RENAME TRUNCATE ","date":"2016-09-19","objectID":"/2016/09/sql-categories/:1:2","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Database"],"content":"数据操纵语言 英语：Data Manipulation Language，缩写：DML 负责对数据库对象运行数据访问工作的指令集。 语法结构 INSERT UPDATE DELETE ","date":"2016-09-19","objectID":"/2016/09/sql-categories/:1:3","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Database"],"content":"数据控制语言 英语：Data Control Language，缩写：DCL 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据看对象的控制权。 语法结构 GRANT REVOKE ","date":"2016-09-19","objectID":"/2016/09/sql-categories/:1:4","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Java"],"content":"背景 此篇只为导航，感谢博客园中的java-my-lift的详细讲解。 每天学一篇设计模式，记录到导航页中，不做转载。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:0","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"1. 简单工厂模式 简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。 例子：登陆－－域名登陆，口令登陆 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:1","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"2. 工厂方法模式 工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式。 工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。 例子：导出文件－－导出Excel，导出HTML，导出PDF ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:2","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"3. 抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 例子：装机工程师组装电脑 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:3","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"4. 单例模式 作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。 4-1. 饿汉式单例模式 空间换时间 类装载的时候就创建实例 public class EagerSingleton { private static EagerSingleton instance = new EagerSingleton(); /** * 私有默认构造子 */ private EagerSingleton(){} /** * 静态工厂方法 */ public static EagerSingleton getInstance(){ return instance; } } 4-2. 懒汉式单例模式 时间换空间 调用时再创建实例 public class LazySingleton { private static LazySingleton instance = null; /** * 私有默认构造子 */ private LazySingleton(){} /** * 静态工厂方法 */ public static synchronized LazySingleton getInstance(){ if(instance == null){ instance = new LazySingleton(); } return instance; } } 4-3. 双重检查加锁 volatile关键字 线程安全 运行效率不高，不建议采用 public class Singleton { private volatile static Singleton instance = null; private Singleton(){} public static Singleton getInstance(){ //先检查实例是否存在，如果不存在才进入下面的同步块 if(instance == null){ //同步块，线程安全的创建实例 synchronized (Singleton.class) { //再次检查实例是否存在，如果不存在才真正的创建实例 if(instance == null){ instance = new Singleton(); } } } return instance; } } 4-4. 类级内部类 延迟加载 线程安全 public class Singleton { private Singleton(){} /** * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例 * 没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。 */ private static class SingletonHolder{ /** * 静态初始化器，由JVM来保证线程安全 */ private static Singleton instance = new Singleton(); } public static Singleton getInstance(){ return SingletonHolder.instance; } } 4-5. 枚举单例 简洁、高效、安全 public enum Singleton { /** * 定义一个枚举的元素，它就代表了Singleton的一个实例。 */ uniqueInstance; /** * 单例可以有自己的操作 */ public void singletonOperation(){ //功能处理 } } ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:4","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"5. 建造模式 建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 例子：订阅杂志，发送欢迎邮件，取消订阅，发送欢送邮件 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:5","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"6. 原型模式 原型模式术语对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是选型模式的用意。 例子：美猴王分身 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:6","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"7. 适配器模式 适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够一起工作。 例子：三相插头转到两相插头的转换器 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:7","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"8. 合成模式 合成模式属于对象的机构模式，有时又叫做“部分－－－－整体”模式。合成模式将对象组装到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:8","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"9. 装饰模式 装饰模式又名包装（Wrapper）模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 例子：齐天大圣七十二变，JAVA I/O库的基本模式 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:9","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"10. 代理模式 代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:10","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"11. 享元模式 享元模式是对象的结构模式。享元模式以共享的方式高效地支持大量的细粒度对象。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:11","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"12. 门面模式 门面模式是对象的结构模式，外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 例子：医院的各个部门由接待员负责。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:12","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"13. 桥梁模式 桥梁模式是对象的结构模式。又称为柄体(Handle and Body)模式或接口(interface)模式。桥梁模式的用意是“将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。 例子：发送消息－－普通消息，加急消息，特急消息 JDBC驱动器就是一个典型的桥梁模式。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:13","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"14. 不变模式 一个对象的状态在对象被创建之后就不再变化，这就是所谓的不变模式。 不变模式只涉及到一个类。一个类的内部状态创建后，在整个生命周期都不会发生变化时，这样的类称作不变类。这种使用不变类的做法叫做不变模式。不变模式有两种形式：一种是弱不变模式，另一种是强不变模式。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:14","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"15. 策略模式 策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生改变。 例子：购物网站，针对不同级别会员打折。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:15","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"16. 模板方法模式 模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模版方法模式的用意。 例子：存款利息－－货币市场和定期存款 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:16","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"17. 观察者模式 观察者模式是对象的行为模式，又叫发布－订阅(Publish/Subscribe)模式、模型－视图(Model/View)模式、源－监听器(Source/Listener)模式或从属者(Dependents)模式。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:17","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"18. 迭代子模式 迭代子模式又叫游标(Cursor)模式，是对象的行为模式。迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象(internal representation)。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:18","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"19. 责任链模式 责任链模式时一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。 例子：击鼓传花 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:19","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"20. 命令模式 命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。 命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队活着记录请求日志，可以提供命令的撤销和恢复功能。 例子：录音机 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:20","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"21. 备忘录模式 备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。 备忘录对象是一个用来存储另外一个对象内部状态的快找的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。 白箱 黑箱 多重检查点 自述历史 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:21","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"22. 状态模式 状态模式，又称状态对象模式（Pattern of Objects for States），状态模式时对象的行为模式。 状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。 例子：在线投票系统－－正常投票、重复投票、恶意刷屏、黑名单 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:22","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"23. 访问者模式 访问者模式是对象的行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:23","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"24. 解释器模式 解释器是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:24","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"25. 调停者模式 调停者模式是对象的行为模式。调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其它的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:25","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Python"],"content":"文章描述","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"学习自廖雪峰的官方网站–Python教程 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:0:0","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"Python的高级特性 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:0","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"切片 创建一个0-99的数列 \u003e\u003e\u003e L = list(range(100)) \u003e\u003e\u003e L [0, 1, 2, 3, ..., 99] 前10个数： \u003e\u003e\u003e L[:10] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数： \u003e\u003e\u003e L[-10:] [90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前11-20个数： \u003e\u003e\u003e L[10:20] [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 前10个数，每两个取一个： \u003e\u003e\u003e L[:10:2] [0, 2, 4, 6, 8] 所有数，每5个取一个： \u003e\u003e\u003e L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 原样复制list \u003e\u003e\u003e L[:] [0, 1, 2, 3, ..., 99] 倒转list \u003e\u003e\u003e L[::-1] [99, 98, 97, 96, ..., 0] tuple切片仍是tuple： \u003e\u003e\u003e (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串也可以当作list来切片 \u003e\u003e\u003e 'ABCDEFG'[:3] 'ABC' \u003e\u003e\u003e 'ABCDEFG'[::2] 'ACEG' ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:1","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"迭代 通过for ... in循环来遍历list或tuple，这种便利称为迭代(iteration)。 迭代dict 默认dict迭代的是key \u003e\u003e\u003e d = {'a': 1, 'b': 2, 'c': 3} \u003e\u003e\u003e for key in d: ... print(key) ... a c b 迭代dict的value \u003e\u003e\u003e for value in d.values(): ... print(value) ... 1 2 3 同时迭代key和value \u003e\u003e\u003e for k, v in d.items(): ... print(k, v) ... b 2 c 3 a 1 判断一个对象是否可迭代 通过collections模块的Iterable类型判断： \u003e\u003e\u003e from collections import Iterable \u003e\u003e\u003e isinstance('abc', Iterable) # str是可迭代对象 True \u003e\u003e\u003e isinstance([1, 2, 3], Iterable) # list是可迭代对象 True \u003e\u003e\u003e isinstance(123, Iterable) # 整数不是可迭代对象 False list实现下标循环 使用Python内置的enumerate函数实现 \u003e\u003e\u003e for i, v in enumerate(['A', 'B', 'C']): ... print(i, v) ... 0 A 1 B 2 C ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:2","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"列表生成式 简单方便的生成list \u003e\u003e\u003e [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] \u003e\u003e\u003e [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] \u003e\u003e\u003e [m + n for m in 'ABC' for n in 'XYZ'] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] \u003e\u003e\u003e d = {'x': 'A', 'y': 'B', 'z': 'C' } \u003e\u003e\u003e [k + '=' + v for k, v in d.items()] ['y=B', 'x=A', 'z=C'] \u003e\u003e\u003e L = ['Hello', 'World', 'IBM', 'Apple'] \u003e\u003e\u003e [s.lower() for s in L] ['hello', 'world', 'ibm', 'apple'] ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:3","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"生成器 把列表生成式的[]改成()就可以创建一个生成器g 通过next(g)打印出来 创建一个斐波拉契数列的生成器 def fib(max): n, a, b = 0, 0, 1 while n \u003c max: yield b a, b = b, a + b n += 1 return 'done' ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:4","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"迭代器 \u003e\u003e\u003e from collections import Iterator \u003e\u003e\u003e isinstance((x for x in range(10)), Iterator) True \u003e\u003e\u003e isinstance([], Iterator) False \u003e\u003e\u003e isinstance({}, Iterator) False \u003e\u003e\u003e isinstance('abc', Iterator) False 凡是可作用于for循环的对象都是Iterable类型； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 from collections import Iterator \u003e\u003e\u003e isinstance(iter([]), Iterator) True \u003e\u003e\u003e isinstance(iter('abc'), Iterator) True ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:5","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"函数式编程 高阶函数 map/reduce map函数：把第一个参数(函数)，作用在第二个参数(Iterable)的每个元素上，并把结果作为新的Iterator返回。 例子: \u003e\u003e\u003e list(map(str, [1, 2, 3, 4, 5, 6, , 7, 8, 9])) ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce函数：第一个参数是函数，第二个参数是序列，函数依次作用于序列的每一个元素，并把结果作用于下一个元素 例子： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) filter 过滤序列。第一个参数是函数，第二个参数是序列，函数依次作用于序列的每一个元素，然后根据返回值True还是False决定保留还是丢弃该元素。 又是惰性的。 def is_odd(n): return n % 2 == 1 list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 结果: [1, 5, 9, 15] sorted sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。 \u003e\u003e\u003e sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) ['Zoo', 'Credit', 'bob', 'about'] 返回函数 一个函数返回另一个函数，不立即执行，调用时执行。 匿名函数 lambda表达式。 f = lambda x : x * x 装饰器 动态增加函数的功能。 import functools def log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s%s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 偏函数 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 \u003e\u003e\u003e import functools \u003e\u003e\u003e int2 = functools.partial(int, base=2) \u003e\u003e\u003e int2('1000000') 64 \u003e\u003e\u003e int2('1010101') 85 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:6","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"面向对象编程 访问限制 定义私有变量，需要在变量前加上两个下划线__，通过get方法获取，或者通过set方法赋值。 不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量 强烈不建议这么干，不同版本的Python解释器可能会改成不同的变量名。 需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 获取对象信息 type() \u003e\u003e\u003e import types \u003e\u003e\u003e def fn(): ... pass ... \u003e\u003e\u003e type(fn)==types.FunctionType True \u003e\u003e\u003e type(abs)==types.BuiltinFunctionType True \u003e\u003e\u003e type(lambda x: x)==types.LambdaType True \u003e\u003e\u003e type((x for x in range(10)))==types.GeneratorType True isinstance() 判断class的继承关系 也能替代type()判断基本类型 还可以判断一个变量是否是某些类型中的一种 \u003e\u003e\u003e isinstance([1, 2, 3], (list, tuple)) True \u003e\u003e\u003e isinstance((1, 2, 3), (list, tuple)) True dir() 如果要获取一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list. 仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:7","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"面向对象高级编程 使用__slots__ 正常可以动态绑定实例的属性和方法，如果在实例中定义一个特殊的__slots__变量，则可以限制该class实例能添加的属性。 使用_slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类不起作用。 使用@property Python内置的@property装饰器就是负责把一个方法变成属性调用。 class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value \u003c 0 or value \u003e 100: raise ValueError('score must between 0 ~ 100!') self._score = value 如果只定义了get方法，没有定义set方法，就是只读属性 定制类 需要特殊变量 __slots__ __len__ __str__ __repr__ __iter__ __next__ __getitem__ __getattr__ __call__ 使用元类 __metaclass__ 理解难点，找到了一个详细讲解的文章 深刻理解Python中的元类(metaclass) 此文章翻译自stackoverflow的一个神回复 what-is-a-metaclass-in-python ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:8","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"错误、调试、和测试 错误处理 捕获异常并处理 try...except...finally... 主动抛出异常 raise 调试 断言 断言返回False的，则抛出AssertionError assert n != 0, 'n is zero!' 启动Python解释器时可以用-0参数来关闭assert python3 -0 err.py logging pdb 让程序以单步方式运行 以参数-m pdb启动 输入命令n可以单步执行代码 输入命令p 变量名来查看变量 输入命令q结束调试，退出程序 也可以设置断点 需要先import pdb 在需要断点的地方放置pdb.set_trace() ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:9","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"IO编程 StringIO和BytesIO 操作文件和目录 OS模块 \u003e\u003e\u003e import os \u003e\u003e\u003e os.name # 操作系统类型 \u003e\u003e\u003e os.uname() # 详细的系统信息 \u003e\u003e\u003e os.environ() # 系统环境变量 \u003e\u003e\u003e os.path.abspath('.') # 当前目录绝对路径 \u003e\u003e\u003e os.path.join('/Users/Bruce', 'testdir') # 拼接路径 \u003e\u003e\u003e os.mkdir('/Users/Bruce/testdir') # 创建目录 \u003e\u003e\u003e os.rmdir('/Users/Bruce/testdir') # 删除目录 \u003e\u003e\u003e os.path.split('/Users/Bruce/testdir/file.txt') ('/Users/Bruce/testdir', 'file.txt') \u003e\u003e\u003e os.rename('test.txt', 'test.py') # 对文件重命名 \u003e\u003e\u003e os.remove('text'.py') # 删除文件 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:10","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"常用内建模块 datetime collections namedtuple depue defaultdict OrderedDict Counter base64 hashlib itertools count() cycle() repeat() takewhile() chain() groupby() XML DOM SAX HTMLParser urllib ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:11","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"常用第三方模块 PIL PIL:Python Imaging Library，强大的图片处理模块 Pillow，在PIL的基础上创建的兼容的版本 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:12","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"异步IO 协程 没有理解，重点看一下。 asyncio async/await aiohttp ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:13","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"文章描述","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"pip基础命令记录–来源自官方文档 ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:0","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"在线安装第三方库 pip install SomePackage ＃ 最新版本 pip install SomePackage==1.0.4 # 指定版本 pip install SomePackage\u003e=1.0.4 # 最低限度版本 同时会安装依赖的其他第三方库 ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:1","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"需要安装的列表文件 pip install -r requirements.txt ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:2","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"导出已安装的第三方库列表 pip freeze \u003e ./requirements.txt ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:3","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"统一将第三方库安装到用户目录下 pip install --user SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:4","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"移除第三方库 pip uninstall SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:5","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查看当前安装的第三方库 pip list ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:6","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查询需要升级的库 pip list --outdated ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:7","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"升级库 pip install --upgrade SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:8","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查看库的详细信息 pip show SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:9","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查看库的安装信息 pip show --files SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:10","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"在线查找第三方库 pip search \"query\" ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:11","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["DevTools","Python"],"content":"文章描述","date":"2016-08-24","objectID":"/2016/08/python-pyenv/","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"pyenv的使用记录 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:0","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"pyenv的仓库地址 https://github.com/yyuu/pyenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:1","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"配合pyenv-virtualenv创建虚拟环境 https://github.com/yyuu/pyenv-virtualenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:2","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"安装pyenv brew install pyenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:3","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"配置pyenv 配置工作目录 export PYENV_ROOT=/usr/local/var/pyenv 添加环境变量 if which pyenv \u003e /dev/null; then eval \"$(pyenv init -)\"; fi ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:4","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"安装pyenv-virtualenv brew install pyenv-virtualenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:5","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"配置pyenv-virtualenv 添加环境变量 if which pyenv-virtualenv-init \u003e /dev/null; then eval \"$(pyenv virtualenv-init -)\"; fi ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:6","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"重新加载SHELL环境，使环境变量生效 exec $SHELL ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:7","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"查看pyenv命令 pyenv commands ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:8","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"查看所有可安装Python版本 pyenv install --list ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:9","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"安装指定版本 pyenv install 2.7.12 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:10","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"本地指定使用已安装的版本 pyenv local 2.7.12 执行👆命令后，会在当前目录生成一个.python-version文件，用于指定当前目录中所使用的python版本。 如果当前目录没有.python-version文件，则会向上级目录查找，当前目录所使用的python版本，与上级目录指定的版本相同。 如果直到根目录都没有找到.python-version文件，则使用global设置的版本 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:11","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"指定全局版本 pyenv global system system为系统默认python版本，非pyenv安装版本。 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:12","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools"],"content":"文章描述","date":"2016-08-19","objectID":"/2016/08/git-tools/","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"Git命令使用记录－来源自官方文档 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:0:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"选择修订版本 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"简短的 SHA-1 查看每次提交简短的SHA-1值 git log --abbrev-commit --pretty=oneline 假设某个提交是1c002dd....，如果你想git show这个提交，下面三个命令是等价的（假设简短的版本没有歧义） git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b git show 1c002dd4b536e7479f git show 1c002dd ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:1","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"分支引用 如果想查看某个分支的最后一次提交信息，可以使用rev-parse探测出该分支的最后一次SHA-1值 git rev-parse \u003cbranchName\u003e 然后再git show打印出的SHA-1值 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:2","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"引用日志 git reflog 如果想查看仓库中HEAD在五次前的所指向的提交 git show HEAD@{5} 如果想查看master分支在昨天的时候指向了哪个提交 git show master@{yesterday} 引用日志只存在于本地仓库，如果查询的时间早于本地最早操作时间，则会显示第一次操作记录 可以运行git log -g来查看类似于git log输出格式的引用日志信息 git log -g master ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:3","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"祖先引用 查看HEAD的上一个提交，也就是“HEAD的父提交”，下面两个命令等价 git show HEAD^ git show HEAD~ 查看HEAD的第二父提交 git show HEAD^2 查看HEAD的第一父提交的第一父提交，下面两个命令等价 git show HEAD^^ git show HEAD~2 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:4","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"提交区间 双点 查看experiment分支中还有哪些提交尚未被合并入master分支 git log master..experiment 查看master分支中存在，而experiment分支中不存在的提交，下面三个命令等价 git log experiment..master git log ^experiment master git log master --not experiment 如果在..的某一边留空，则默认为HEAD 多点 查看所有被refA或refB包含的但是不被refC包含的提交，下面两个命令等价 git log refA refB ^refC git log refA refB --not refC 三点 查看master或者experiment中包含的但不是两者共有的提交 git log master...experiment 如果加上参数--left-right，会显示每个提交到底处于哪一侧的分支 git log --left-right master...experiment ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:5","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"交互式暂存 如果运行git add时使用-i或者--interactive选项，Git将会进入交互式终端模式 git add -i git add --interactive ","date":"2016-08-19","objectID":"/2016/08/git-tools/:2:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"储藏与清理 如果想要切换分支，但是不想提交之前修改的文件，这时需要用到储藏 git stash git stash save 这时就可以轻易的切换分支并在其他地方工作，如果想要查看储藏 git stash list 如果想要重新应用储藏，执行👇命令，如果不指定一个储藏，则默认最近一个 git stash apply git stash apply stash@{2} 重新应用后，之前暂存的文件并没有重新暂存，这时需要--index选项 git stash apply --index 重新应用后，堆栈上的储藏并不会删除，可以使用删除命令 git stash drop stash@{2} 如果想要将储藏重新应用后立即从栈上删除，可以使用👇的命令 git stash pop 如果不想储藏已暂存的文件，需要--keep-index选项 git stash save --keep-index 如果想储藏未跟踪文件，需要--include-untracked或-u选项 git stash save -u 如果指定了--patch标记，Git会交互式的提示储藏 git stash --patch ","date":"2016-08-19","objectID":"/2016/08/git-tools/:3:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"从储藏创建一个分支 如果重新应用储藏时，可能会有冲突，这时可能会想创建一个新分支，并在新分支上重新应用储藏 git stash branch \u003cbranchName\u003e ","date":"2016-08-19","objectID":"/2016/08/git-tools/:3:1","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"清理工作目录 移除所有未被忽略并且未被追踪的文件，非常危险！ git clean 更安全一些的命令，将所有文件储藏 git stash --all git clean的一些选项 查看git clean将会做什么，-n git clean -n 移除工作目录中所有未追踪的文件以及空的子目录，-d git clean -n -d 强制移除，确定移除，-f git clean -n -d -f 移除.gitignore文件忽略的文件类型，-x git clean -n -d -x -f 以交互模式运行clean命令，-i git clean -x -i ","date":"2016-08-19","objectID":"/2016/08/git-tools/:3:2","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"特殊合并 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:4:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"合并某个分支上的单个commit 假设将feature分支上的commitfdb7b6合并到master分支，不合并其它commit: 先查找想要合并的commit的SHA－1值； 再checkout到想要合并的分支； git checkout master 最后执行cherry-pick命令: git cherry-pick fdb7b6 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:4:1","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"合并某个分支上的一系列commits 假设将feature分支上的commitfdb7b6 至d46ee6合并到master分支 首先，在feature分支基础上创建一个新分支，并且指明最后一个commit git checkout -b newBranch d46ee6 然后，使用rebase命令合并到master分支，要指明合并开始的commit git rebase --onto master fdb7b6^ to be continue... ","date":"2016-08-19","objectID":"/2016/08/git-tools/:4:2","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["Java"],"content":"文章描述","date":"2016-08-17","objectID":"/2016/08/java-hibernate-null-insert-mysql/","tags":["Hibernate"],"title":"MySQL表中字段有非空限制，Hibernate添加默认值","uri":"/2016/08/java-hibernate-null-insert-mysql/"},{"categories":["Java"],"content":"问题背景 Java开发中，使用Hibernate作为映射数据库的表，所以创建了一个modle类 @javax.persistence.Entity @javax.persistence.Table(name = \"HibernateTest\") public class HibernateTest extends BaseModel { private static final long serialVersionUID = 9124938173965082237L; private Long id; private String name; private Integer age; @javax.persistence.Id @javax.persistence.GeneratedValue(strategy = javax.persistence.GenerationType.IDENTITY) @javax.persistence.Column(name = \"Id\") public Long getId() { return id; } public void setId(Long id) { this.id = id; } @javax.persistence.Column(name = \"Name\") public String getName() { return name; } public void setName(String name) { this.name = name; } @javax.persistence.Column(name = \"Age\") public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 对应的数据库，由于DBA要求非字符串字段必须有默认值，则 CREATE TABLE `HibernateTest` ( `Id` bigint(16) NOT NULL AUTO_INCREMENT COMMENT '主键', `Name` varchar(32) DEFAULT NULL COMMENT '名称', `Age` int(8) NOT NULL DEFAULT '-1' COMMENT '年龄', PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 这种情况下，使用Hibernate默认的save或update方法来添加或修改数据，如果有非空约束的字段(比如Age)没有赋值，会抛出异常。 因为Hibernate执行save或update时，会将映射类中的所有映射字段加入到生成的SQL语句中，所以导致数据库报错。 ","date":"2016-08-17","objectID":"/2016/08/java-hibernate-null-insert-mysql/:1:0","tags":["Hibernate"],"title":"MySQL表中字段有非空限制，Hibernate添加默认值","uri":"/2016/08/java-hibernate-null-insert-mysql/"},{"categories":["Java"],"content":"解决方法 在映射类的类名上方，添加注解 @org.hibernate.annotations.Entity(dynamicInsert = true, dynamicUpdate = true) 这样Hibernate在执行save或update方法时，映射类中映射字段为NULL的，就不会加入到最后生成的SQL语句中了。 ","date":"2016-08-17","objectID":"/2016/08/java-hibernate-null-insert-mysql/:2:0","tags":["Hibernate"],"title":"MySQL表中字段有非空限制，Hibernate添加默认值","uri":"/2016/08/java-hibernate-null-insert-mysql/"},{"categories":["DevTools"],"content":"文章描述","date":"2016-08-16","objectID":"/2016/08/git-basics/","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"Git命令使用记录－来源自官方文档 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:0:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"1. Git起步 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:1:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"1.1 配置文件 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。 用户信息 设置用户名称与邮件地址 git config --global user.name \"BruceMaa\" git config --global user.email BruceMaa@example.com 文本编辑器 默认是VIM，可配置为emacs git config --global core.editor emacs 检查配置信息 列出所有Git当时能找到的配置 git config --list Git会将三个位置的配置信息都列出来，所以可能会有重复，如果只想查看当前信息 git config user.name 打开当前仓库的配置文件 git config -e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:1:1","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"1.2 获取帮助 若你使用Git时需要获取帮助，有三种方法可以找到Git命令的使用手册: git help \u003cverb\u003e git \u003cverb\u003e --help man git-\u003cverb\u003e 例如，要想获得config命令的手册，执行 git help config ","date":"2016-08-16","objectID":"/2016/08/git-basics/:1:2","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2. Git基础 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.1 获取Git仓库 在现有目录中初始化仓库 初始化 git init 克隆仓库 克隆 git clone [url] 克隆仓库，自定义本地仓库名字 克隆，自定义本地仓库名字 git clone [url] [newRepo] ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:1","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.2 记录每次更新到仓库 检查当前文件状态 git status 跟踪新文件，并将文件暂存 git add file 交互式暂存 git add --interactive 等同于 git add -i 状态简览 git status -s ?? 表示新添加文件，但未跟踪 A 表示新添加文件，并放入暂存区中 左M 表示暂存区的文件已被修改，并放入暂存区中 右M 表示暂存区的文件已被修改，并未放入暂存区中 忽略文件 创建.gitignore文件，列出要忽略的文件模式，可用正则表达式 查看尚未暂存的文件更新了哪些部分 git diff 查看已暂存的文件未提交的更新部分 git diff --staged 提交更新 此命令提交，会显示core.editor设置的编辑器，填写提交信息 git commit 将提交信息于命令放在同一行 git commit -m \"new commit\" 不使用git add命令，将已跟踪过的文件暂存起来一并提交 git commit -a -m \"new commit\" 移除文件 git rm file 记得从工作目录中删除，这样就不会出现在未跟踪文件清单中了,如果已经放到暂存区的话，则要用强制删除选项 -f 从仓库中删除，但本地保留 git rm --cached file 移动文件 git mv file_from file_to ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:2","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.3 查看提交历史 git log -p 显示每次提交的内容差异，-2 显示最近两次提交 git log -p -2 –stat 查看每次提交的简略的统计信息 git log --stat –pretty 格式化显示内容，内建子选项 oneline, short, full和fuller git log --pretty=oneline 定制记录格式 git log --pretty=format:\"%h - %an, %ar : %s\" 显示精简SHA－1值 git log --abbrev-commit --pretty=oneline 引用日志 git reflog 查看5次前所指向的提交 git show HEAD@{5} 查看master分支昨天指向哪个提交 git show master@{yesterday} 父引用 需要在引用的后面加上一个^ HEAD的第一次父提交 git show HEAD^ HEAD的第二次父提交 git show HEAD^2 HEAD的第一次父提交的第一次父提交 git show HEAD^^ 等同于 git show HEAD~2 提交区间 双点 查看experiment分支上有哪些提交尚未合并到master分支上 git log master..experiment 查看在master分支中而不在experiment分支中的提交 git log experiment..master 查看即将推送到远端的内容,下面两个相同 git log origin/master..HEAD git log origin/master.. 多点 查看所有被refA或refB包含但是不被refC包含的提交，下面两个相同 git log refA refB ^refC git log refA refB --not refC 三点 查看master或者experiment中包含，但不是两者共有的的提交 git log master...experiment 还可以加参数–left-right，它会显示每一个提交属于哪一个分支 git log --left-right master...experiment format常用选项 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 当oneline或format与另一个log选项–graph结合使用时尤其有用，这个选项添加了一些ASCII字符串来形象的展示分支、合并历史： git log --pretty=format:\"%h %s\" --graph git log 的常用选项 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 限制git log 输出的选项 选项 说明 -(n) 仅显示最近的 n 条提交 –since, –after 仅显示指定时间之后的提交。 –until, –before 仅显示指定时间之前的提交。 –author 仅显示指定作者相关的提交。 –committer 仅显示指定提交者相关的提交。 –grep 仅显示含指定关键字的提交 -S 仅显示添加或移除了某个关键字的提交 如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令： git log --pretty=\"%h - %s\" --author=gitster --since=\"2008-10-01\" --before=\"2008-11-01\" --no-merges ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:3","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.4 撤销操作 更改上次提交 上次提交后发现有漏提交文件，将漏提交文件放到暂存区，然后执行命令 git commit --amend 取消暂存的文件 git reset HEAD \u003cfile\u003e 撤消对文件的修改 git checkout -- \u003cfile\u003e 撤消提交 撤消最近一次commit，数字可变。在这之后的commit全部舍弃 git reset --hard HEAD~1 撤消最近一次commit，数字可变，在这之后的commit都变成暂存状态，等待提交 git reset --soft HEAD~1 回滚最后一次提交 git reset --soft HEAD^ ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:4","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.5 远程仓库 查看原创仓库 git remote git remote -v 添加远程仓库 git remote add \u003cshortname\u003e \u003curl\u003e 从远程仓库拉取信息 git fetch \u003cshortname\u003e 从远程仓库抓取信息然后合并远程分支到当前分支 git pull 推送到远程仓库 git push [remote-name] [branch-name] 查看远程仓库 git remote show origin 重命名远程仓库 git remote rename \u003coldName\u003e \u003cnewName\u003e 移除远程仓库 git remote rm \u003cremote-name\u003e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:5","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.6 打标签 列出标签 git tag 可以过滤结果 git tag -l 'v1.0.1*' 创建标签 附注标签 git tag -a v1.0 -m 'version 1.0' 轻量标签 git tag v1.0-rc 查看标签信息 git show \u003ctagName\u003e 后期打标签 git log --pertty=oneline 然后在打标签的命令后面加上该次提交的校验值(可以是部分) git tag -a V1.2 9fceb02 共享标签 git push origin \u003ctagname\u003e 如果想要一次推送很多标签 git push origin --tags 检出标签 git checkout -b \u003cbranchname\u003e \u003ctagname\u003e 删除标签 git push origin --delete tag \u003ctagname\u003e 或者，先本地删除标签，再将空标签推送到远程标签，等同于删除标签 git tag -d \u003ctagname\u003e git push origin :refs/tags/\u003ctagname\u003e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:6","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.7 Git 别名 git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:7","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3 分支 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.1 分支简介 分支创建 在当前所在的分支基础上创建新分支 git branch testing 分支切换 git checkout testing 查看分叉历史 git log --oneline --decorate --graph --all ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:1","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.2 分支的新建与合并 新建分支 git checkout -b iss53 等同于下面两条命令 git branch iss53 git checkout iss53 分支的合并 将iss53分支合并到master git checkout master git merge iss53 合并时有冲突 修改冲突后，需要查看文件状态，把未提交的提交 git status 删除分支 git branch -d hotfix ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:2","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.3 分支管理 分支列表 git branch 查看每一个分支的最后一次提交 git branch -v 查看哪些分支已经合并到当前分支 git branch --merged 查看所有包含未合并工作的分支 git branch --no-merged 强制删除未合并过的分支 git branch -D testing 重命名本地分支 git branch -m \u003coldBranchName\u003e \u003cnewBranchName\u003e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:3","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.3 远程分支 查看远程仓库的远程分支 git ls-remote origin 推送本地分支到远程仓库 git push (remote) (branch) 推送本地分支到远程仓库，并且取不同名字 git push (remote) (local_branch):(new_branch) 跟踪分支 git checkout --track origin/serverfix 修改正在跟踪的上游分支 git branch -u origin/newBranch 或 git branch --set-upstream-to origin/newBranch 查看所有跟踪分支 git branch -vv 如果有显示远程分支显示，并且有ahead提示，则有未推送到远程分支，有behind则表示远程服务器有提交未合并到本地，都没有则表示和远程分支同步； 如果没有显示远程分支，则表示未跟踪远程分支。 如果想查看最新情况，则需要先抓取所有远程仓库，再查看: git fetch --all 拉取 git pull 等同于 git fetch;git merge 删除远程分支 git push origin --delete \u003cdelBranch\u003e 或者，推送一个空分支到远程分支，等同于删除远程分支 git push origin :\u003cdelBranch\u003e 删除本地仓库中，远程已经删除的分支 远程删除了某个分支，本地执行抓取或者拉取时，并不会将本地对应的该分支也一并删除，使用 git remote show origin 命令查看时，正常的跟踪分支状态为tracked，已删除的分支状态为stale，并且Git提示可以使用命令删除 git remote prune 还有一种简单的命令 git fetch -p ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:4","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.4 变基 变基的基本操作 检出新分支，coding git checkout experiment 变基到想要合并的分支 git rebase master 回到master分支 git checkout master 快进合并 git merge experiment 多重分支变基 从master分支创建server分支，再从server创建client分支，现在想先将client分支变基到master分支,再快进合并： git rebase --onto master server client git checkout master git merge client 再将server分支变基到master分支，再快进合并 git rebase master server git merge server 不需切换分支，直接变基某个分支 git rebase [basebranch] [topicbranch] ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:5","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"}]